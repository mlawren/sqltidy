#!/usr/bin/perl

use strict;
use warnings;
use SQL::Tree;

our $VERSION = '0.2';

use Getopt::Long;

my %options = ();
GetOptions(
    'help'            => \$options{'help'},
    'double-escape'   => \$options{'double-escape'},
    'preserve-indent' => \$options{'preserve-indent'},
    'editor-mode'     => \$options{'editor-mode'},
    'no-editor-mode'  => \$options{'no-editor-mode'},
);

if ( $options{'help'} ) {
    print << "_HELP_";

    Usage: $0 [options] [file]

    This tool takes SQL and reformats it in an aesthetically pleasing way.
    It can be run stand-alone (passing a file as an argument) or can be run
    in-place on code in your text editor.

    FILE

    If a filename is passed as an argument to the script, the script will
    non-destructively create a new, tidied version of the file, with the
    extension .tdy appended to the original filename.

    If a filename is not passed, then the script will read from STDIN and
    output the tidied SQL to STDOUT.  This makes it suitable for in-place
    edits in your favorite text editor.  In this case, double-escape and
    preserve-indent are enabled by default unless explicitly calling
    --no-editor-mode.

    This is the same behavior as perltidy.

    OPTIONS

    --help              Displays this help message.

    --double-escape     Expect two escape characters (\\\\) instead of just
                        one. This may be needed if your sql is embedded in
                        another language, which requires that the escape
                        character itself be escaped.

    --preserve-indent   Preserve the indentation in the existing file.
                        This sets the indentation to be the least-indented
                        line of the SQL statement.

    --editor-mode       Enable both --double-escape and --preserve-indent
                        options, making it suitable for being called from
                        Perl in the same way as perltidy.  Enabled by
                        default when invoked without a file (using STDIN).

    --no-editor-mode    Don't invoke editor mode by default when calling
                        sqltidy without a file.
_HELP_
    exit;
}

## File name is optionally passed in as an argument

my $filename = $ARGV[0];

## If SQL is from STDIN, or editor-mode is set, set two additional flags.
## If no-editor-mode is set, don't add these flags on STDIN input.

if ( $options{'editor-mode'} or ( !$filename && !$options{'no-editor-mode'} ) )
{
    $options{'double-escape'}   = 1;
    $options{'preserve-indent'} = 1;
}

##################################################

## Get the original SQL - read from STDIN if filename is undef

my $sql = _get_raw_sql($filename);

## Parse the SQL and generate the new SQL

my $tree   = new SQL::Tree($sql);
my $output = $tree->pretty();

## Post-processing steps with additional formatting

$output = _double_escape($output)           if $options{'double-escape'};
$output = _preserve_indent( $output, $sql ) if $options{'preserve-indent'};

## Print to file.tdy, or STDOUT if it was originally from STDIN

if ($filename) {
    _save_file( $output, "$filename.tdy" );
}
else {
    print $output;
}

##################################################

sub _get_raw_sql {
    my ($filename) = @_;

    my $sql = undef;

    if ($filename) {

        # try to open the file and read in the data
        if ( open( my $file, $filename ) ) {
            local $/ = undef;
            my $sql = <$file>;
            return $sql;
        }
        else {
            die "ERROR: Could not open file |$filename| for reading.\n";
        }
    }
    else {
        # read from STDIN
        local $/ = undef;
        $sql = <>;
    }

    return $sql;
}

sub _save_file {
    my ( $output, $filename ) = @_;

    if ( open( my $file, '>', $filename ) ) {
        print $file $output;
        close $file;
    }
    else {
        die "Couldn't open |$filename| for writing.\n";
    }
}

sub _double_escape {
    my ($output) = @_;

    # \ becomes \\
    $output =~ s!\\!\\\\!igs;

    return $output;
}

sub _preserve_indent {
    my ( $output, $original ) = @_;

    # find the index of the left-most non-space character on any line
    my $min_length = 10**10;
    for ( split /\n/, $original ) {
        /^(\s+)/;
        my $cur_length = $1 ? length($1) : 0;
        $min_length = $cur_length < $min_length ? $cur_length : $min_length;

        # shortcut out if we find a zero-indent line
        return $output if $min_length == 0;
    }

    # indent everything by that much
    my $new_output = '';
    my $indent     = " " x $min_length;

    for ( split /\n/, $output ) {
        $new_output .= "$indent$_\n";
    }

    return $new_output;
}
